import fs from "node:fs";
import path from "node:path";
import * as v from "valibot";
import prettier from "prettier";
import { rimraf } from "rimraf";
import template from "lodash.template";
import { registrySchema, type RegistryItemType } from "@shadcn-svelte/registry";
import { colorMapping, colors } from "../src/lib/registry/colors.js";
import { themes } from "../src/lib/registry/themes.js";
import { buildRegistry } from "./registry.js";
import {
	BASE_STYLES,
	BASE_STYLES_WITH_VARIABLES,
	THEME_STYLES_WITH_VARIABLES,
} from "../src/lib/registry/templates.js";

const prettierConfig = await prettier.resolveConfig(import.meta.url);
if (!prettierConfig) throw new Error("Failed to resolve prettier config.");

const REGISTRY_PATH = path.resolve("static", "registry");
const THEMES_CSS_PATH = path.resolve("static");

function writeFileWithDirs(
	filePath: string,
	data: string,
	options: Parameters<typeof fs.writeFileSync>[2] = {}
) {
	// Create directory path if it doesn't exist
	const dirname = path.dirname(filePath);
	fs.mkdirSync(dirname, { recursive: true });

	// Write the file
	fs.writeFileSync(filePath, data, options);
}

async function buildRegistryJson(style: "default" | "new-york") {
	const registry = await buildRegistry(style);
	const selfReferenced = registry.filter((item) =>
		item.registryDependencies?.includes(item.name)
	);
	const selfReferenceError = selfReferenced
		.map((item) => `Registry item '${item.name}' depends on itself`)
		.join("\n");
	if (selfReferenceError) {
		throw new Error(selfReferenceError);
	}

	// ----------------------------------------------------------------------------
	// Build `registry.json` file.
	// ----------------------------------------------------------------------------
	const result = v.parse(registrySchema, {
		name: "shadcn-svelte",
		homepage: "https://shadcn-svelte.com",
		overrideDependencies: ["paneforge@next", "vaul-svelte@next"],
		items: registry,
		aliases: {
			lib: `$lib/registry/${style}/lib`,
			ui: `$lib/registry/${style}/ui`,
			components: `$lib/registry/${style}/components`,
			hooks: `$lib/registry/${style}/hooks`,
			utils: "$lib/utils",
		},
	});
	const ITEM_TYPES: RegistryItemType[] = [
		"registry:ui",
		"registry:hook",
		"registry:style",
		"registry:lib",
	];
	const filteredItems = result.items.filter((item) => ITEM_TYPES.includes(item.type));
	const registryJsonPath = path.resolve(`registry-${style}.json`);
	const registryJson = JSON.stringify({ ...result, items: filteredItems }, null, "\t");
	const formatted = await prettier.format(registryJson, {
		...prettierConfig,
		filepath: registryJsonPath,
	});
	fs.writeFileSync(registryJsonPath, formatted, "utf8");
	return result;
}

const STYLES = ["default", "new-york"] as const;

export async function build() {
	const defaultRegistry = await buildRegistryJson("default");
	const newYorkRegistry = await buildRegistryJson("new-york");

	// ----------------------------------------------------------------------------
	// Build blocks registry (__registry__/blocks.js)
	// ----------------------------------------------------------------------------
	let blocksIndex = `
// This file is autogenerated by scripts/build-registry.ts
// Do not edit this file directly.
export const Blocks = {
`;
	for (const style of STYLES) {
		blocksIndex += `\t"${style}": {`;
		const result = style === "default" ? defaultRegistry : newYorkRegistry;

		for (const block of result.items) {
			if (block.type !== "registry:block") continue;

			const isDir = !fs.existsSync(
				path.resolve("src", "lib", "registry", style, "blocks", `${block.name}.svelte`)
			);
			const blockFile = isDir ? `${block.name}/+page.svelte` : `${block.name}.svelte`;

			blocksIndex += `
	"${block.name}": {
		name: "${block.name}",
		type: "${block.type}",
		component: () => import("../lib/registry/${style}/blocks/${blockFile}").then((m) => m.default),
		raw: () => import("../lib/registry/${style}/blocks/${blockFile}?raw").then((m) => m.default),
	},`;
		}
		// end of style
		blocksIndex += `\n\t},`;
	}
	blocksIndex += "\n};\n";

	const blocksPath = path.resolve("src", "__registry__", "blocks.js");
	writeFileWithDirs(blocksPath, blocksIndex);

	// ----------------------------------------------------------------------------
	// Build __registry__/ui.js.
	// ----------------------------------------------------------------------------
	let uiIndex = `// This file is autogenerated by scripts/build-registry.ts
// Do not edit this file directly.
export const UI = {`;

	for (const style of STYLES) {
		const result = style === "default" ? defaultRegistry : newYorkRegistry;
		uiIndex += `\t"${style}": {`;
		for (const item of result.items) {
			if (item.type !== "registry:ui") continue;
			uiIndex += `
"${item.name}": {
	name: "${item.name}",
	type: "${item.type}",
},`;
		}
		// end of style
		uiIndex += `\n\t},`;
	}
	uiIndex += `
}
`;

	const uiPath = path.resolve("src", "__registry__", "ui.js");
	writeFileWithDirs(uiPath, uiIndex);

	// ----------------------------------------------------------------------------
	// Build __registry__/index.js.
	// ----------------------------------------------------------------------------
	let index = `
// This file is autogenerated by scripts/build-registry.ts
// Do not edit this file directly.
export const Index = {
`;

	for (const style of STYLES) {
		const result = style === "default" ? defaultRegistry : newYorkRegistry;
		index += `\t"${style}": {`;

		// Build style index.
		for (const item of result.items) {
			if (item.type === "registry:ui" || item.type === "registry:block") {
				continue;
			}
			const type = item.type.split(":")[1] + "s";

			const resolveFiles = item.files.map((file) => file.path.replace("src/", "../"));
			const componentLine =
				item.type === "registry:hook"
					? "component: () => {}"
					: `component: () => import("../lib/registry/${style}/${type}/${item.name}.svelte").then((m) => m.default)`;

			index += `
		"${item.name}": {
			name: "${item.name}",
			type: "${item.type}",
			registryDependencies: ${JSON.stringify(item.registryDependencies)},
			${componentLine},
			files: [${resolveFiles.map((file) => `"${file.replaceAll(path.sep, "/")}"`)}],
			raw: () => import("../lib/registry/${style}/${type}/${item.name}.svelte?raw").then((m) => m.default),
			},`;
		}
		// end of style
		index += `\n\t},`;
	}

	index += `
}
`;

	// Write style index.
	const registryPath = path.resolve("src", "__registry__", "index.js");
	rimraf.sync(registryPath);
	writeFileWithDirs(registryPath, index);

	// ----------------------------------------------------------------------------
	// Build registry/colors/index.json.
	// ----------------------------------------------------------------------------
	for (const style of STYLES) {
		const colorsTargetPath = path.join(REGISTRY_PATH, style, "colors");
		rimraf.sync(colorsTargetPath);
		if (!fs.existsSync(colorsTargetPath)) {
			fs.mkdirSync(colorsTargetPath, { recursive: true });
		}

		// eslint-disable-next-line @typescript-eslint/no-explicit-any
		const colorsData: Record<string, any> = {};
		for (const [color, value] of Object.entries(colors)) {
			if (typeof value === "string") {
				colorsData[color] = value;
				continue;
			}

			if (Array.isArray(value)) {
				colorsData[color] = value.map((item) => ({
					...item,
					rgbChannel: item.rgb.replace(/^rgb\((\d+),(\d+),(\d+)\)$/, "$1 $2 $3"),
					hslChannel: item.hsl.replace(
						/^hsl\(([\d.]+),([\d.]+%),([\d.]+%)\)$/,
						"$1 $2 $3"
					),
				}));
				continue;
			}

			if (typeof value === "object") {
				colorsData[color] = {
					...value,
					rgbChannel: value.rgb.replace(/^rgb\((\d+),(\d+),(\d+)\)$/, "$1 $2 $3"),
					hslChannel: value.hsl.replace(
						/^hsl\(([\d.]+),([\d.]+%),([\d.]+%)\)$/,
						"$1 $2 $3"
					),
				};
				continue;
			}

			writeFileWithDirs(
				path.join(colorsTargetPath, "index.json"),
				JSON.stringify(colorsData[style], null, "\t"),
				"utf-8"
			);
		}

		// ----------------------------------------------------------------------------
		// Build registry/colors/[base].json.
		// ----------------------------------------------------------------------------
		for (const baseColor of ["slate", "gray", "zinc", "neutral", "stone", "lime"]) {
			// eslint-disable-next-line @typescript-eslint/no-explicit-any
			const base: Record<string, any> = {
				inlineColors: {},
				cssVars: {},
			};
			for (const [mode, values] of Object.entries(colorMapping)) {
				base.inlineColors[mode] = {};
				base.cssVars[mode] = {};
				for (const [key, value] of Object.entries(values)) {
					if (typeof value === "string") {
						const resolvedColor = value.replace(/\{\{base\}\}-/g, `${baseColor}-`);
						base.inlineColors[mode][key] = resolvedColor;

						const [resolvedBase, scale] = resolvedColor.split("-");
						const color = scale
							? colorsData[resolvedBase].find(
									// eslint-disable-next-line @typescript-eslint/no-explicit-any
									(item: any) => item.scale === Number.parseInt(scale)
								)
							: colorsData[resolvedBase];
						if (color) {
							base.cssVars[mode][key] = color.hslChannel;
						}
					}
				}
			}

			// Build css vars.
			base.inlineColorsTemplate = template(BASE_STYLES)({});
			base.cssVarsTemplate = template(BASE_STYLES_WITH_VARIABLES)({
				colors: base.cssVars,
			});

			writeFileWithDirs(
				path.join(colorsTargetPath, `${baseColor}.json`),
				JSON.stringify(base, null, "\t"),
				"utf-8"
			);
		}
	}

	// ----------------------------------------------------------------------------
	// Build registry/themes.css
	// ----------------------------------------------------------------------------

	const themeCSS = [];
	for (const theme of themes) {
		themeCSS.push(
			template(THEME_STYLES_WITH_VARIABLES)({
				colors: theme.cssVars,
				theme: theme.name,
			})
		);
	}

	writeFileWithDirs(path.join(THEMES_CSS_PATH, `themes.css`), themeCSS.join("\n"), "utf-8");

	console.info("âœ… Done!");
}

// await build();
