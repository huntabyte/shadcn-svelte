import template from "lodash.template";
import fs from "node:fs";
import path from "node:path";
import { rimraf } from "rimraf";
import { generateBaseColorTemplate, getColorsData } from "../src/lib/components/colors/colors.js";
import { registrySchema, type RegistryItemType } from "../src/lib/registry/schema";
import { baseColors } from "../src/lib/registry/colors.js";
import { buildRegistry } from "./registry";
import { THEME_STYLES_WITH_VARIABLES } from "../src/lib/registry/templates";
import { getChunks } from "./transform-chunks";

const REGISTRY_PATH = path.resolve("static", "registry");
const THEMES_CSS_PATH = path.resolve("static");
const REGISTRY_IGNORE = ["super-form"];

function writeFileWithDirs(
	filePath: string,
	data: string,
	options: Parameters<typeof fs.writeFileSync>[2] = {}
) {
	// Create directory path if it doesn't exist
	const dirname = path.dirname(filePath);
	fs.mkdirSync(dirname, { recursive: true });

	// Write the file
	fs.writeFileSync(filePath, data, options);
}

async function main() {
	const registry = await buildRegistry();

	const selfReferenced = registry.filter((item) => item.registryDependencies.includes(item.name));
	const selfReferenceError = selfReferenced
		.map((item) => `Registry item '${item.name}' depends on itself`)
		.join("\n");
	if (selfReferenceError) {
		throw new Error(selfReferenceError);
	}

	const result = registrySchema.parse(registry);

	// ----------------------------------------------------------------------------
	// Build blocks registry (__registry__/blocks.js) and block chunks (__registry__/chunks/[style]/[block]-[chunk].svelte)
	// ----------------------------------------------------------------------------
	const registryChunksDirPath = path.resolve("src", "__registry__", "chunks");
	const libPath = path.resolve("src", "lib", "registry");
	rimraf.sync(registryChunksDirPath);
	let blocksIndex = `
// This file is autogenerated by scripts/build-registry.ts
// Do not edit this file directly.
export const Blocks = {
`;

	const chunkStyleDir = path.resolve(registryChunksDirPath);
	// Create directory if it doesn't exist.
	if (!fs.existsSync(chunkStyleDir)) {
		fs.mkdirSync(chunkStyleDir, { recursive: true });
	}
	// Creates chunk files
	for (const block of result) {
		if (block.type !== "registry:block") continue;
		const file = block.files[0];
		const blockPath = path.resolve(libPath, "block", file.name);
		const chunkDir = path.resolve(registryChunksDirPath);

		const chunks = getChunks(file.content, blockPath);
		for (const chunk of chunks) {
			const chunkPath = path.resolve(chunkDir, `${chunk.name}.svelte`);
			writeFileWithDirs(chunkPath, chunk.content, { encoding: "utf8" });
		}

		const isDir = !fs.existsSync(
			path.resolve("src", "lib", "registry", "block", `${block.name}.svelte`)
		);
		const blockFile = isDir ? `${block.name}/+page.svelte` : `${block.name}.svelte`;

		blocksIndex += `
	"${block.name}": {
		name: "${block.name}",
		type: "${block.type}",
		chunks: [${chunks.map((chunk) => ` { name: "${chunk.name}", description: "${chunk.description}", container: { className: "${chunk.container.className}" }, raw: () => import("./chunks/${chunk.name}.svelte?raw").then((m) => m.default), component: () => import("./chunks/${chunk.name}.svelte").then((m) => m.default) }`)}],
		component: () => import("../lib/registry/block/${blockFile}").then((m) => m.default),
		raw: () => import("../lib/registry/block/${blockFile}?raw").then((m) => m.default),
	},`;
	}

	blocksIndex += "\n};\n";
	const blocksPath = path.resolve("src", "__registry__", "blocks.js");
	writeFileWithDirs(blocksPath, blocksIndex);

	// ----------------------------------------------------------------------------
	// Build __registry__/index.js.
	// ----------------------------------------------------------------------------
	let index = `
// This file is autogenerated by scripts/build-registry.ts
// Do not edit this file directly.
export const Index = {
`;

	// Build style index.
	for (const item of result) {
		if (item.type === "registry:ui" || item.type === "registry:block") {
			continue;
		}
		const type = item.type.split(":")[1];

		const resolveFiles = item.files.map((file) => `../lib/registry/${file.path}`);
		const componentLine =
			item.type === "registry:hook"
				? "component: () => {}"
				: `component: () => import("../lib/registry/${type}/${item.name}.svelte").then((m) => m.default)`;

		index += `
"${item.name}": {
	name: "${item.name}",
	type: "${item.type}",
	registryDependencies: ${JSON.stringify(item.registryDependencies)},
	${componentLine},
	files: [${resolveFiles.map((file) => `"${file.replaceAll("\\", "/")}"`)}],
	raw: () => import("../lib/registry/${type}/${item.name}.svelte?raw").then((m) => m.default),
},`;
	}

	index += `
}
`;

	// Write style index.
	const registryPath = path.resolve("src", "__registry__", "index.js");
	rimraf.sync(registryPath);
	writeFileWithDirs(registryPath, index);

	// ----------------------------------------------------------------------------
	// Build registry/[name].json.
	// ----------------------------------------------------------------------------
	// Create the registry directory
	const targetPath = path.join(REGISTRY_PATH);

	// Create directory if it doesn't exist.
	if (!fs.existsSync(targetPath)) {
		fs.mkdirSync(targetPath, { recursive: true });
	}

	for (const item of result) {
		const allowedTypes: RegistryItemType[] = ["registry:ui", "registry:hook", "registry:block"];
		if (!allowedTypes.includes(item.type)) continue;

		// discard `path` prop
		const files = item.files.map((file) => ({ ...file, path: undefined }));
		const filePath = path.resolve(targetPath, `${item.name}.json`);

		const payload = {
			...item,
			files,
		};

		writeFileWithDirs(filePath, JSON.stringify(payload, null, "\t"), "utf-8");
	}

	// ----------------------------------------------------------------------------
	// Build registry/index.json.
	// ----------------------------------------------------------------------------
	const ITEM_TYPES: RegistryItemType[] = ["registry:ui", "registry:hook"];
	const names = result
		.filter((item) => ITEM_TYPES.includes(item.type) && !REGISTRY_IGNORE.includes(item.name))
		.map((item) => {
			const filePath = path.resolve(REGISTRY_PATH, `${item.name}.json`);
			const relativeUrlPath = path.relative(targetPath, filePath).split(path.sep).join("/");
			return {
				...item,
				// The `default` style uses `@lucide/svelte`, so we'll discard it for the purposes of the index
				dependencies: item.dependencies.filter((dep) => dep !== "@lucide/svelte"),
				// We only want the relative file paths
				files: item.files.map((file) => ({
					path: file.path,
					type: "registry:ui",
				})),
				// Registry item's endpoint, relative to the registry's index
				relativeUrl: relativeUrlPath,
			};
		});
	const registryJson = JSON.stringify(names, null, "\t");
	rimraf.sync(path.join(REGISTRY_PATH, "index.json"));
	writeFileWithDirs(path.join(REGISTRY_PATH, "index.json"), registryJson, "utf-8");

	// ----------------------------------------------------------------------------
	// Build registry/colors/index.json.
	// ----------------------------------------------------------------------------
	const colorsTargetPath = path.join(REGISTRY_PATH, "colors");
	rimraf.sync(colorsTargetPath);
	if (!fs.existsSync(colorsTargetPath)) {
		fs.mkdirSync(colorsTargetPath, { recursive: true });
	}

	const colorsData = getColorsData();

	writeFileWithDirs(
		path.join(colorsTargetPath, "index.json"),
		JSON.stringify(colorsData, null, "\t"),
		"utf-8"
	);

	// ----------------------------------------------------------------------------
	// Build registry/colors/[base].json.
	// ----------------------------------------------------------------------------

	const themeCSS = [];
	for (const baseColor of baseColors) {
		const base = generateBaseColorTemplate(baseColor);

		themeCSS.push(
			template(THEME_STYLES_WITH_VARIABLES)({
				colors: base.cssVars,
				theme: baseColor,
			})
		);

		writeFileWithDirs(
			path.join(REGISTRY_PATH, "colors", `${baseColor}.json`),
			JSON.stringify(base, null, "\t"),
			"utf-8"
		);
	}

	// ----------------------------------------------------------------------------
	// Build registry/themes.css
	// ----------------------------------------------------------------------------

	writeFileWithDirs(path.join(THEMES_CSS_PATH, `themes.css`), themeCSS.join("\n\n"), "utf-8");

	console.info("âœ… Done!");
}

await main();
