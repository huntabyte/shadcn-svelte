import template from "lodash.template";
import fs from "node:fs";
import path from "node:path";
import * as v from "valibot";
import prettier from "prettier";
import { rimraf } from "rimraf";
import {
	registrySchema,
	type Registry,
	type RegistryItem,
	type RegistryItemType,
} from "@shadcn-svelte/registry";
import { buildRegistry } from "./registry.js";
import { BASE_STYLES_WITH_VARIABLES } from "../src/lib/registry/templates.js";
import { baseColorsV4 } from "../src/lib/registry/registry-base-colors";
import { colorMapping, colors } from "../src/lib/registry/registry-colors";

const prettierConfig = await prettier.resolveConfig(import.meta.url);
if (!prettierConfig) throw new Error("Failed to resolve prettier config.");

const REGISTRY_PATH = path.resolve("static", "registry");

function writeFileWithDirs(
	filePath: string,
	data: string,
	options: Parameters<typeof fs.writeFileSync>[2] = {}
) {
	// Create directory path if it doesn't exist
	const dirname = path.dirname(filePath);
	fs.mkdirSync(dirname, { recursive: true });

	// Write the file
	fs.writeFileSync(filePath, data, options);
}

export async function build() {
	const registry = await buildRegistry();

	const selfReferenced = registry.filter((item) => item.registryDependencies.includes(item.name));
	const selfReferenceError = selfReferenced
		.map((item) => `Registry item '${item.name}' depends on itself`)
		.join("\n");
	if (selfReferenceError) {
		throw new Error(selfReferenceError);
	}

	const initItem: RegistryItem = {
		name: "init",
		type: "registry:style",
		devDependencies: ["tailwind-variants", "@lucide/svelte", "tw-animate-css"],
		registryDependencies: ["utils"],
		files: [],
		cssVars: {},
	};

	// ----------------------------------------------------------------------------
	// Build `registry.json` file.
	// ----------------------------------------------------------------------------
	const result = v.parse(registrySchema, {
		$schema: "./static/schema/registry.json",
		name: "shadcn-svelte",
		homepage: "https://shadcn-svelte.com",
		aliases: {
			lib: "$lib/registry/lib",
			ui: "$lib/registry/ui",
			components: "$lib/registry/components",
			hooks: "$lib/registry/hooks",
			utils: "$lib/utils",
		},
		// TODO: remove when moving from `next` to `latest`
		overrideDependencies: ["paneforge@next", "vaul-svelte@next"],
		items: [initItem, ...registry],
	} as Registry);

	const ITEM_TYPES: RegistryItemType[] = [
		"registry:ui",
		"registry:hook",
		"registry:style",
		"registry:lib",
		"registry:block",
	];
	const filteredItems = result.items.filter((item) => ITEM_TYPES.includes(item.type));
	const registryJsonPath = path.resolve("registry.json");

	const registryJson = JSON.stringify({ ...result, items: filteredItems }, null, "\t");
	const formatted = await prettier.format(registryJson, {
		...prettierConfig,
		filepath: registryJsonPath,
	});
	fs.writeFileSync(registryJsonPath, formatted, "utf8");

	let blocksIndex = `
// This file is autogenerated by scripts/build-registry.ts
// Do not edit this file directly.
export const Blocks = {
`;

	// Creates block index files
	for (const block of result.items) {
		if (block.type !== "registry:block") continue;

		const isDir = !fs.existsSync(
			path.resolve("src", "lib", "registry", "blocks", `${block.name}.svelte`)
		);
		const blockFile = isDir ? `${block.name}/+page.svelte` : `${block.name}.svelte`;

		blocksIndex += `
	"${block.name}": {
		component: () => import("../lib/registry/blocks/${blockFile}").then((m) => m.default),
		raw: () => import("../lib/registry/blocks/${blockFile}?raw").then((m) => m.default),
	},`;
	}

	blocksIndex += "\n};\n";
	const blocksPath = path.resolve("src", "__registry__", "blocks.js");
	writeFileWithDirs(blocksPath, blocksIndex);

	// ----------------------------------------------------------------------------
	// Build __registry__/index.js.
	// ----------------------------------------------------------------------------
	let index = `
// This file is autogenerated by scripts/build-registry.ts
// Do not edit this file directly.
export const Index = {`;

	// Build style index.
	for (const item of result.items) {
		if (item.type !== "registry:example") {
			continue;
		}
		// pluralize
		const type = item.type.split(":")[1] + "s";

		const resolveFiles = item.files.map((file) => file.path.replace("src/", "../"));

		index += `
"${item.name}": {
	name: "${item.name}",
	type: "${item.type}",
	registryDependencies: ${JSON.stringify(item.registryDependencies)},
	component: () => import("../lib/registry/${type}/${item.name}.svelte").then((m) => m.default),
	files: [${resolveFiles.map((file) => `"${file.replaceAll(path.sep, "/")}"`)}],
	raw: () => import("../lib/registry/${type}/${item.name}.svelte?raw").then((m) => m.default),
},`;
	}

	index += `
}
`;

	// Write style index.
	const registryPath = path.resolve("src", "__registry__", "index.js");
	rimraf.sync(registryPath);
	writeFileWithDirs(registryPath, index);

	// ----------------------------------------------------------------------------
	// Build registry/colors/index.json.
	// ----------------------------------------------------------------------------
	const colorsTargetPath = path.join(REGISTRY_PATH, "colors");
	rimraf.sync(colorsTargetPath);
	if (!fs.existsSync(colorsTargetPath)) {
		fs.mkdirSync(colorsTargetPath, { recursive: true });
	}

	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	const colorsData: Record<string, any> = {};
	for (const [color, value] of Object.entries(colors)) {
		if (typeof value === "string") {
			colorsData[color] = value;
			continue;
		}

		if (Array.isArray(value)) {
			colorsData[color] = value.map((item) => ({
				...item,
				rgbChannel: item.rgb.replace(/^rgb\((\d+),(\d+),(\d+)\)$/, "$1 $2 $3"),
				hslChannel: item.hsl.replace(/^hsl\(([\d.]+),([\d.]+%),([\d.]+%)\)$/, "$1 $2 $3"),
			}));
			continue;
		}

		if (typeof value === "object") {
			colorsData[color] = {
				...value,
				rgbChannel: value.rgb.replace(/^rgb\((\d+),(\d+),(\d+)\)$/, "$1 $2 $3"),
				hslChannel: value.hsl.replace(/^hsl\(([\d.]+),([\d.]+%),([\d.]+%)\)$/, "$1 $2 $3"),
			};
			continue;
		}
	}

	fs.writeFileSync(
		path.join(colorsTargetPath, "index.json"),
		JSON.stringify(colorsData, null, 2),
		"utf8"
	);

	// ----------------------------------------------------------------------------
	// Build registry/colors/[base].json.
	// ----------------------------------------------------------------------------

	for (const baseColor of ["slate", "gray", "zinc", "neutral", "stone"] as const) {
		// eslint-disable-next-line @typescript-eslint/no-explicit-any
		const base: Record<string, any> = {
			inlineColors: {},
			cssVars: {},
		};
		for (const [mode, values] of Object.entries(colorMapping)) {
			base["inlineColors"][mode] = {};
			base["cssVars"][mode] = {};
			for (const [key, value] of Object.entries(values)) {
				if (typeof value === "string") {
					// Chart colors do not have a 1-to-1 mapping with tailwind colors.
					if (key.startsWith("chart-")) {
						base["cssVars"][mode][key] = value;
						continue;
					}

					const resolvedColor = value.replace(/{{base}}-/g, `${baseColor}-`);
					base["inlineColors"][mode][key] = resolvedColor;
				}
			}
		}

		base["cssVars"] = baseColorsV4[baseColor];
		base["cssVarsTemplate"] = template(BASE_STYLES_WITH_VARIABLES)({
			colors: base["cssVars"],
		});
		base["inlineColorsTemplate"] = `@import "tailwindcss";
@import "tw-animate-css";`;

		// themeCSS.push(
		// 	template(THEME_STYLES_WITH_VARIABLES)({
		// 		colors: baseColorsV4[baseColor],
		// 		theme: baseColor,
		// 	})
		// );

		writeFileWithDirs(
			path.join(REGISTRY_PATH, "colors", `${baseColor}.json`),
			JSON.stringify(base, null, "\t"),
			"utf-8"
		);
	}

	// ----------------------------------------------------------------------------
	// Build registry/themes.css
	// ----------------------------------------------------------------------------

	// writeFileWithDirs(path.join(THEMES_CSS_PATH, `themes.css`), themeCSS.join("\n\n"), "utf-8");
}
