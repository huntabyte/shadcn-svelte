#!/usr/bin/env tsx
import * as fs from "fs/promises";
import { watch } from "fs";
import * as path from "path";
import { iconLibraries, type IconLibraryName } from "shadcn-svelte/icons";
import { pascalToKebab } from "$lib/registry/lib/casing.js";

const SEARCH_BASE = "src/";
const REGISTRY_BASE = "src/lib/registry";

type IconUsage = Record<IconLibraryName, Set<string>>;

async function findSvelteFiles(dir: string) {
	const files: string[] = [];
	const entries = await fs.readdir(dir, { withFileTypes: true });

	for (const entry of entries) {
		const fullPath = path.join(dir, entry.name);
		if (entry.isDirectory()) {
			files.push(...(await findSvelteFiles(fullPath)));
		} else if (entry.isFile() && entry.name.endsWith(".svelte")) {
			files.push(fullPath);
		}
	}

	return files;
}

async function scanIconUsage() {
	const iconUsage = Object.fromEntries(
		Object.keys(iconLibraries).map((key) => [key, new Set<string>()])
	) as IconUsage;

	const searchBasesDir = path.join(process.cwd(), SEARCH_BASE);
	const files = await findSvelteFiles(searchBasesDir);

	for (const file of files) {
		const content = await fs.readFile(file, "utf-8");

		for (const [libraryName, config] of Object.entries(iconLibraries)) {
			const regex = new RegExp(`${config.name}=["']([^"']+)["']`, "g");
			let match;
			while ((match = regex.exec(content)) !== null) {
				iconUsage[libraryName as IconLibraryName].add(match[1]);
			}
		}
	}

	return iconUsage;
}

async function generateIconFiles(iconUsage: IconUsage) {
	const outputDir = path.join(process.cwd(), REGISTRY_BASE, "icons");

	console.log("✓ Generated icon files:");

	for (const [lib, config] of Object.entries(iconLibraries)) {
		const libraryName = lib as IconLibraryName;
		const icons = Array.from(iconUsage[libraryName]).sort();

		if (icons.length === 0) {
			continue;
		}

		const typeName = `${config.title.replace(/\s/g, "")}IconName`;
		const typeUnion = icons.map((icon) => `"${icon}"`).join(" | ");

		const indexFileContent = `// Auto-generated by scripts/build-icons.ts
export type ${typeName} = ${typeUnion};
`;

		const dirname = `__${libraryName}__`;

		const iconFiles = icons.map((icon) => {
			let iconWithoutSuffix = icon;
			if (libraryName === "lucide" || libraryName === "phosphor") {
				if (icon !== "Icon") {
					iconWithoutSuffix = icon.endsWith("Icon") ? icon.slice(0, -4) : icon;
				}
			}
			const iconKebab = pascalToKebab(iconWithoutSuffix);
			const iconExport = iconLibraries[libraryName].export
				.replaceAll("ICON_KEBAB", iconKebab)
				.replaceAll("ICON_WO_SUFFIX", iconWithoutSuffix)
				// we use the original icon name for ICON
				.replaceAll("ICON", icon);

			return {
				name: icon,
				content: `// Auto-generated by scripts/build-icons.ts\n${iconExport}\n`,
			};
		});

		await fs.mkdir(path.join(outputDir, dirname), { recursive: true });
		await fs.mkdir(outputDir, { recursive: true });
		await fs.writeFile(path.join(outputDir, dirname, "index.ts"), indexFileContent);
		for (const iconFile of iconFiles) {
			await fs.writeFile(
				path.join(outputDir, dirname, `${iconFile.name}.ts`),
				iconFile.content
			);
		}

		console.log(`  - ${config.title}: ${icons.length} icons`);
	}
}

async function main() {
	const iconUsage = await scanIconUsage();
	await generateIconFiles(iconUsage);
}

const isWatchMode = process.argv.includes("--watch");

if (isWatchMode) {
	const SEARCH_DIR = path.join(process.cwd(), SEARCH_BASE);

	await main();

	watch(SEARCH_DIR, { recursive: true }, (_, filename) => {
		if (!filename?.endsWith(".svelte")) return;

		main().catch((error) => {
			console.error("❌ Icons build failed:", error);
		});
	});
} else {
	await main();
}
