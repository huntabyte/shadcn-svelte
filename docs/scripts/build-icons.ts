#!/usr/bin/env tsx
import * as fs from "fs";
import * as path from "path";
import { iconLibraries, type IconLibraryName } from "shadcn-svelte/icons";
import { pascalToKebab } from "$lib/registry/lib/casing.js";

const REGISTRY_BASE = "src/lib/registry";

type IconUsage = Record<IconLibraryName, Set<string>>;

function findTsxFiles(dir: string) {
	const files: string[] = [];
	const entries = fs.readdirSync(dir, { withFileTypes: true });

	for (const entry of entries) {
		const fullPath = path.join(dir, entry.name);
		if (entry.isDirectory()) {
			files.push(...findTsxFiles(fullPath));
		} else if (entry.isFile() && entry.name.endsWith(".svelte")) {
			files.push(fullPath);
		}
	}

	return files;
}

function scanIconUsage() {
	const iconUsage: IconUsage = Object.keys(iconLibraries).reduce((acc, key) => {
		acc[key as IconLibraryName] = new Set();
		return acc;
	}, {} as IconUsage);

	const registryBasesDir = path.join(process.cwd(), REGISTRY_BASE);
	const files = findTsxFiles(registryBasesDir);
	const libraryNames = Object.values(iconLibraries)
		.map((lib) => lib.name)
		.join("|");
	const iconPlaceholderRegex = new RegExp(
		`<IconPlaceholder\\s+([^>]*?)(?:${libraryNames})=["']([^"']+)["']([^>]*?)\\/?>`,
		"g"
	);

	for (const file of files) {
		const content = fs.readFileSync(file, "utf-8");

		let match;
		while ((match = iconPlaceholderRegex.exec(content)) !== null) {
			const fullMatch = match[0];

			for (const [libraryName, config] of Object.entries(iconLibraries)) {
				const attrMatch = fullMatch.match(new RegExp(`${config.name}=["']([^"']+)["']`));
				if (attrMatch) {
					iconUsage[libraryName as IconLibraryName].add(attrMatch[1]);
				}
			}
		}
	}

	return iconUsage;
}

function generateIconFiles(iconUsage: IconUsage) {
	const outputDir = path.join(process.cwd(), REGISTRY_BASE, "icons");

	console.log("✓ Generated icon files:");

	Object.entries(iconLibraries).forEach(([lib, config]) => {
		const libraryName = lib as IconLibraryName;
		const icons = Array.from(iconUsage[libraryName]).sort();

		if (icons.length === 0) {
			return;
		}

		const content = `// Auto-generated by scripts/build-icons.ts
${icons
	.map((icon) => {
		let iconWithoutSuffix = icon;
		if (libraryName === "lucide" || libraryName === "phosphor") {
			if (icon !== "Icon") {
				iconWithoutSuffix = icon.endsWith("Icon") ? icon.slice(0, -4) : icon;
			}
		}
		const iconKebab = pascalToKebab(iconWithoutSuffix);

		return (
			iconLibraries[libraryName].export
				.replaceAll("ICON_KEBAB", iconKebab)
				.replaceAll("ICON_WO_SUFFIX", iconWithoutSuffix)
				// we use the original icon name for ICON
				.replaceAll("ICON", icon)
		);
	})
	.join("\n")}
`;

		const filename = `__${libraryName}__.ts`;
		if (!fs.existsSync(outputDir)) {
			fs.mkdirSync(outputDir, { recursive: true });
		}
		fs.writeFileSync(path.join(outputDir, filename), content);

		console.log(`  - ${config.title}: ${icons.length} icons`);
	});
}

function main() {
	const iconUsage = scanIconUsage();
	generateIconFiles(iconUsage);
}

const isWatchMode = process.argv.includes("--watch");

if (isWatchMode) {
	const REGISTRY_DIR = path.join(process.cwd(), REGISTRY_BASE);

	main();

	fs.watch(REGISTRY_DIR, { recursive: true }, (_, filename) => {
		if (!filename?.endsWith(".svelte")) return;

		try {
			main();
		} catch (error) {
			console.error("❌ Icons build failed:", error);
		}
	});
} else {
	main();
}
