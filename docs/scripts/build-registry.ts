import fs from "node:fs";
import path from "node:path";
import prettier from "prettier";
import { rimraf } from "rimraf";
import {
	componentsJsonSchema,
	registryItemSchema,
	registrySchema,
	type Registry,
	type RegistryItem,
	type RegistryItemType,
} from "@shadcn-svelte/registry";

interface BuildRegistryItem {
	name: string;
	type: string;
	files: Array<{
		path: string;
	}>;
}
import { buildRegistry } from "./registry.js";
import { THEMES } from "../src/lib/registry/themes.js";
import { getColorsData } from "../src/lib/components/colors/colors.js";
import { toJSONSchema } from "zod";

const prettierConfig = await prettier.resolveConfig(import.meta.url);
if (!prettierConfig) throw new Error("Failed to resolve prettier config.");

const INTERNAL_REGISTRY_PATH = path.resolve("src", "lib", "registry");
const REGISTRY_PATH = path.resolve("static", "registry");

function writeFileWithDirs(
	filePath: string,
	data: string,
	options: Parameters<typeof fs.writeFileSync>[2] = {}
): void {
	// Create directory path if it doesn't exist
	const dirname = path.dirname(filePath);
	fs.mkdirSync(dirname, { recursive: true });

	// Write the file
	fs.writeFileSync(filePath, data, options);
}

export async function build(): Promise<void> {
	const registry = await buildRegistry();

	const selfReferenced = registry.filter(
		(item) => item.registryDependencies?.includes(item.name) ?? false
	);
	const selfReferenceError = selfReferenced
		.map((item) => `Registry item '${item.name}' depends on itself`)
		.join("\n");
	if (selfReferenceError) {
		throw new Error(selfReferenceError);
	}

	const initItem: RegistryItem = {
		name: "init",
		type: "registry:style",
		devDependencies: ["tailwind-variants", "tw-animate-css"],
		registryDependencies: ["utils"],
		files: [],
	};

	// ----------------------------------------------------------------------------
	// Build `registry.json` file.
	// ----------------------------------------------------------------------------
	const result = registrySchema.parse(
		{
			$schema: "./static/schema/registry.json",
			name: "shadcn-svelte",
			homepage: "https://shadcn-svelte.com",
			aliases: {
				lib: "$lib/registry/lib",
				ui: "$lib/registry/ui",
				components: "./components",
				hooks: "$lib/registry/hooks",
				utils: "$lib/utils",
			},
			// TODO: remove when moving from `next` to `latest`
			overrideDependencies: ["vaul-svelte@next"],
			items: [initItem, ...registry],
		} as Registry,
		// maintains the schema defined property order
		{ jitless: true }
	);

	const ITEM_TYPES: RegistryItemType[] = [
		"registry:ui",
		"registry:hook",
		"registry:style",
		"registry:lib",
		"registry:block",
	];
	const filteredItems = result.items.filter((item) => ITEM_TYPES.includes(item.type));
	const registryJsonPath = path.resolve("registry.json");

	const registryJson = JSON.stringify({ ...result, items: filteredItems }, null, "\t");
	const formatted = await prettier.format(registryJson, {
		...prettierConfig,
		filepath: registryJsonPath,
	});
	fs.writeFileSync(registryJsonPath, formatted, "utf8");

	// ----------------------------------------------------------------------------
	// Build __registry__/blocks.ts
	// ----------------------------------------------------------------------------
	rimraf.sync(path.resolve("src", "__registry__"));

	let blocksIndex = `
// This file is autogenerated by scripts/build-registry.ts
// Do not edit this file directly.
export const blocks = [
`; // Creates block index files
	for (const block of result.items) {
		if (block.type !== "registry:block" || block.name.startsWith("chart-")) continue;

		blocksIndex += `"${block.name}",`;
	}

	blocksIndex += "\n] as const;\n";
	const blocksPath = path.resolve("src", "__registry__", "blocks.ts");
	writeFileWithDirs(blocksPath, blocksIndex);

	// ----------------------------------------------------------------------------
	// Build __registry__/index.js.
	// ----------------------------------------------------------------------------
	let index = `
// This file is autogenerated by scripts/build-registry.ts
// Do not edit this file directly.
export const Index = {`;

	// TODO: fix later - we should either add these calendar examples to
	// the `lib/registry/examples` dir, or... do something else?
	const CALENDAR_EXAMPLES = ["02", "13", "22", "24", "29"].map((n) => `calendar-${n}`);

	for (const item of result.items as BuildRegistryItem[]) {
		if (item.type !== "registry:example" && !CALENDAR_EXAMPLES.includes(item.name)) {
			continue;
		}

		const resolveFiles = item.files.map((file: BuildRegistryItem["files"][0]) =>
			file.path.replace("src/", "../")
		);

		index += `
"${item.name}": {
	files: [${resolveFiles.map((filePath: string) => `"${filePath.replaceAll(path.sep, "/")}"`)}],
},`;
	}

	index += `
}
`;

	// Write style index.
	const registryPath = path.resolve("src", "__registry__", "index.js");
	rimraf.sync(registryPath);
	writeFileWithDirs(registryPath, index);

	// ----------------------------------------------------------------------------
	// Build registry/colors/index.json.
	// ----------------------------------------------------------------------------
	const colorsTargetPath = path.join(REGISTRY_PATH, "colors");
	rimraf.sync(colorsTargetPath);
	if (!fs.existsSync(colorsTargetPath)) {
		fs.mkdirSync(colorsTargetPath, { recursive: true });
	}

	const colorsData = getColorsData();

	writeFileWithDirs(
		path.join(colorsTargetPath, "index.json"),
		JSON.stringify(colorsData, null, "\t"),
		"utf-8"
	);

	// ----------------------------------------------------------------------------
	// Build registry/colors/[theme].json
	// ----------------------------------------------------------------------------

	for (const theme of THEMES) {
		writeFileWithDirs(
			path.join(REGISTRY_PATH, "colors", `${theme.name}.json`),
			JSON.stringify(theme, null, "\t"),
			"utf-8"
		);
	}

	// ----------------------------------------------------------------------------
	// Build registry/styles/[style].css
	// ----------------------------------------------------------------------------
	const styles = fs
		.readdirSync(path.join(INTERNAL_REGISTRY_PATH, "styles"))
		.filter((file) => file.endsWith(".css"));
	fs.mkdirSync(path.join(REGISTRY_PATH, "styles"), { recursive: true });
	for (const style of styles) {
		fs.copyFileSync(
			path.join(INTERNAL_REGISTRY_PATH, "styles", style),
			path.join(REGISTRY_PATH, "styles", style.replace("style-", ""))
		);
	}

	// ----------------------------------------------------------------------------
	// Build static/schema.json
	// ----------------------------------------------------------------------------
	const componentsJSON = toJSONSchema(componentsJsonSchema);
	writeFileWithDirs(
		path.resolve("static", "schema.json"),
		JSON.stringify(componentsJSON, null, "\t")
	);

	const SCHEMA_DIR = path.resolve("static", "schema");
	writeFileWithDirs(
		path.resolve(SCHEMA_DIR, "registry.json"),
		JSON.stringify(toJSONSchema(registrySchema), null, "\t")
	);

	writeFileWithDirs(
		path.resolve(SCHEMA_DIR, "registry-item.json"),
		JSON.stringify(toJSONSchema(registryItemSchema), null, "\t")
	);
}

if (process.argv.includes("build-registry")) {
	build();
}
