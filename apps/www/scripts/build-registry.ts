/* eslint-disable @typescript-eslint/no-explicit-any */
import fs from "fs";
import path, { basename } from "path";
import template from "lodash.template";
import { rimraf } from "rimraf";

import { colorMapping, colors } from "../src/lib/registry/colors";
import { registrySchema } from "../src/lib/registry/schema";
import { styles } from "../src/lib/registry/styles";
import { themes } from "../src/lib/registry/themes";
import { buildRegistry } from "./registry";
import { transformContent } from "./transformers";
import { BASE_STYLES, BASE_STYLES_WITH_VARIABLES, THEME_STYLES_WITH_VARIABLES } from "./templates";

const REGISTRY_PATH = path.join(process.cwd(), "static/registry");
const REGISTRY_IGNORE = ["super-form"];

async function main() {
	const registry = await buildRegistry();
	const result = registrySchema.safeParse(registry);

	if (!result.success) {
		console.error(result.error);
		process.exit(1);
	}

	// ----------------------------------------------------------------------------
	// Build __registry__/index.js.
	// ----------------------------------------------------------------------------
	let index = `
// This file is autogenerated by scripts/build-registry.ts
// Do not edit this file directly.
export const Index = {
`;

	for (const style of styles) {
		index += `	"${style.name}": {`;

		// Build style index.
		for (const item of result.data) {
			if (item.type === "components:ui") {
				continue;
			}

			const resolveFiles = item.files.map(
				(file) => `../src/lib/registry/${style.name}/${file}`
			);

			const type = item.type.split(":")[1];
			index += `
		"${item.name}": {
			name: "${item.name}",
			type: "${item.type}",
			registryDependencies: ${JSON.stringify(item.registryDependencies)},
			component: () => import("../src/lib/registry/${style.name}/${type}/${
				item.name
			}.svelte").then((m) => m.default),
			files: [${resolveFiles.map((file) => `"${file}"`)}],
		},`;
		}

		index += `
	},`;
	}

	index += `
}
`;

	// Write style index.
	rimraf.sync(path.join(process.cwd(), "__registry__/index.js"));
	fs.writeFileSync(path.join(process.cwd(), "__registry__/index.js"), index);

	// ----------------------------------------------------------------------------
	// Build registry/styles/[style]/[name].json.
	// ----------------------------------------------------------------------------
	for (const style of styles) {
		const targetPath = path.join(REGISTRY_PATH, "styles", style.name);
		const targetJsPath = targetPath + "-js";

		// Create directory if it doesn't exist.
		if (!fs.existsSync(targetPath)) {
			fs.mkdirSync(targetPath, { recursive: true });
		}

		// Create JS directory if it doesn't exist.
		if (!fs.existsSync(targetJsPath)) {
			fs.mkdirSync(targetJsPath, { recursive: true });
		}

		for (const item of result.data) {
			if (item.type !== "components:ui") {
				continue;
			}

			const files = item.files?.map((file) => {
				const content = fs.readFileSync(
					path.join(process.cwd(), "src/lib/registry", style.name, file),
					"utf8"
				);

				return {
					name: basename(file),
					content,
				};
			});

			const jsFiles = await Promise.all(
				files.map(async (file) => {
					const content = await transformContent(file.content, file.name);
					const fileName = file.name.replace(".ts", ".js");
					return {
						name: fileName,
						content,
					};
				})
			);

			const payload = {
				...item,
				files,
			};

			const jsPayload = {
				...item,
				files: jsFiles,
			};

			fs.writeFileSync(
				path.join(targetPath, `${item.name}.json`),
				JSON.stringify(payload, null, "\t"),
				"utf8"
			);

			fs.writeFileSync(
				path.join(targetJsPath, `${item.name}.json`),
				JSON.stringify(jsPayload, null, "\t"),
				"utf8"
			);
		}
	}

	// ----------------------------------------------------------------------------
	// Build registry/styles/index.json.
	// ----------------------------------------------------------------------------
	const stylesJson = JSON.stringify(styles, null, "\t");
	fs.writeFileSync(path.join(REGISTRY_PATH, "styles/index.json"), stylesJson, "utf8");

	// ----------------------------------------------------------------------------
	// Build registry/index.json.
	// ----------------------------------------------------------------------------
	const names = result.data.filter(
		(item) => item.type === "components:ui" && !REGISTRY_IGNORE.includes(item.name)
	);
	const registryJson = JSON.stringify(names, null, "\t");
	rimraf.sync(path.join(REGISTRY_PATH, "index.json"));
	fs.writeFileSync(path.join(REGISTRY_PATH, "index.json"), registryJson, "utf8");

	// ----------------------------------------------------------------------------
	// Build registry/colors/index.json.
	// ----------------------------------------------------------------------------
	const colorsTargetPath = path.join(REGISTRY_PATH, "colors");
	rimraf.sync(colorsTargetPath);
	if (!fs.existsSync(colorsTargetPath)) {
		fs.mkdirSync(colorsTargetPath, { recursive: true });
	}

	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	const colorsData: Record<string, any> = {};
	for (const [color, value] of Object.entries(colors)) {
		if (typeof value === "string") {
			colorsData[color] = value;
			continue;
		}

		if (Array.isArray(value)) {
			colorsData[color] = value.map((item) => ({
				...item,
				rgbChannel: item.rgb.replace(/^rgb\((\d+),(\d+),(\d+)\)$/, "$1 $2 $3"),
				hslChannel: item.hsl.replace(/^hsl\(([\d.]+),([\d.]+%),([\d.]+%)\)$/, "$1 $2 $3"),
			}));
			continue;
		}

		if (typeof value === "object") {
			colorsData[color] = {
				...value,
				rgbChannel: value.rgb.replace(/^rgb\((\d+),(\d+),(\d+)\)$/, "$1 $2 $3"),
				hslChannel: value.hsl.replace(/^hsl\(([\d.]+),([\d.]+%),([\d.]+%)\)$/, "$1 $2 $3"),
			};
			continue;
		}
	}

	fs.writeFileSync(
		path.join(colorsTargetPath, "index.json"),
		JSON.stringify(colorsData, null, "\t"),
		"utf8"
	);

	// ----------------------------------------------------------------------------
	// Build registry/colors/[base].json.
	// ----------------------------------------------------------------------------

	for (const baseColor of ["slate", "gray", "zinc", "neutral", "stone", "lime"]) {
		const base: Record<string, any> = {
			inlineColors: {},
			cssVars: {},
		};
		for (const [mode, values] of Object.entries(colorMapping)) {
			base["inlineColors"][mode] = {};
			base["cssVars"][mode] = {};
			for (const [key, value] of Object.entries(values)) {
				if (typeof value === "string") {
					const resolvedColor = value.replace(/{{base}}-/g, `${baseColor}-`);
					base["inlineColors"][mode][key] = resolvedColor;

					const [resolvedBase, scale] = resolvedColor.split("-");
					const color = scale
						? colorsData[resolvedBase].find(
								(item: any) => item.scale === parseInt(scale)
							)
						: colorsData[resolvedBase];
					if (color) {
						base["cssVars"][mode][key] = color.hslChannel;
					}
				}
			}
		}

		// Build css vars.
		base["inlineColorsTemplate"] = template(BASE_STYLES)({});
		base["cssVarsTemplate"] = template(BASE_STYLES_WITH_VARIABLES)({
			colors: base["cssVars"],
		});

		fs.writeFileSync(
			path.join(REGISTRY_PATH, `colors/${baseColor}.json`),
			JSON.stringify(base, null, "\t"),
			"utf8"
		);
	}

	// ----------------------------------------------------------------------------
	// Build registry/themes.css
	// ----------------------------------------------------------------------------

	const themeCSS = [];
	for (const theme of themes) {
		themeCSS.push(
			template(THEME_STYLES_WITH_VARIABLES)({
				colors: theme.cssVars,
				theme: theme.name,
			})
		);
	}

	fs.writeFileSync(path.join(REGISTRY_PATH, `themes.css`), themeCSS.join("\n"), "utf8");

	console.log("âœ… Done!");
}

await main();
